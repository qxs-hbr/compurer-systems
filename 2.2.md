#2.2整数表示#

##2.2.1整数数据类型##

这里主要还是提示我们数据类型的取值范围。64位机比32位机的取值范围要大。

[https://blog.csdn.net/ysvae/article/details/81090846](https://blog.csdn.net/ysvae/article/details/81090846)

这里可以看到负数的范围要比整数大1.

	注 c与c++都支持有符号（默认）和无符号数。java只支持有符号数。

##2.2.2无符号数的编码##

这样的编码是一个**双射**

也就是说无符号编码塔每一个介于0~2w-1之间的数都有一个唯一的数与之对应。

##2.2.3补码编码##

将最高有效位成为符号位，他的“权重”。为-2^(w-1),是无符号表示中权重的负数。当符号位设置为1时，表示值为负，0时值为非负。

举例
[https://blog.csdn.net/weixin_44793395/article/details/106167584](https://blog.csdn.net/weixin_44793395/article/details/106167584)
 
这里看出与无符号数的位模式是相同的只是最高位的权重位值不同。
https://images2017.cnblogs.com/blog/1120165/201709/1120165-20170917152625485-1064687560.png

这样补码的范围就可以来表示下最小值为[100...0]其整数值为-2^(w-1)
而最大值是[011...1],整数值为2^(w-1)-1

以长度四为例子 最大值就是7最小值-8.

##2.2.4有符号数和无符号数之间的转换##

大多数c语言的实现，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是：数值可能改变，但是位模式不改变。

例如 

`unsigned u =4294967295u; /Umax/`

`int tu= (int) u`

`printf("u=%u,tu=%d\n",u ,tu)`

这串代码在采用补码的机器上输出

u=4294967295 ,tu=-1

因为32位下的Umax的位模式是0xFFFFFFFF而-1的 位模式符也是0xFFFFFFFF

在符号转换时保持位模式不改变。