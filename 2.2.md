# 2.2整数表示#

## 2.2.1整数数据类型##

这里主要还是提示我们数据类型的取值范围。64位机比32位机的取值范围要大。

[https://blog.csdn.net/ysvae/article/details/81090846](https://blog.csdn.net/ysvae/article/details/81090846)

这里可以看到负数的范围要比整数大1.

	注 c与c++都支持有符号（默认）和无符号数。java只支持有符号数。

## 2.2.2无符号数的编码##

这样的编码是一个**双射**

也就是说无符号编码塔每一个介于0~2w-1之间的数都有一个唯一的数与之对应。

## 2.2.3补码编码##

将最高有效位成为符号位，他的“权重”。为-2^(w-1),是无符号表示中权重的负数。当符号位设置为1时，表示值为负，0时值为非负。

举例
[https://blog.csdn.net/weixin_44793395/article/details/106167584](https://blog.csdn.net/weixin_44793395/article/details/106167584)
 
这里看出与无符号数的位模式是相同的只是最高位的权重位值不同。
https://images2017.cnblogs.com/blog/1120165/201709/1120165-20170917152625485-1064687560.png

这样补码的范围就可以来表示下最小值为[100...0]其整数值为-2^(w-1)
而最大值是[011...1],整数值为2^(w-1)-1

以长度四为例子 最大值就是7最小值-8.

## 2.2.4有符号数和无符号数之间的转换##

大多数c语言的实现，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是：数值可能改变，但是位模式不改变。

例如 

`unsigned u =4294967295u; /Umax/`

`int tu= (int) u`

`printf("u=%u,tu=%d\n",u ,tu)`

这串代码在采用补码的机器上输出

u=4294967295 ,tu=-1

因为32位下的Umax的位模式是0xFFFFFFFF而-1的 位模式符也是0xFFFFFFFF在符号转换时保持位模式不改变

无符号数表示中的Umax有着和补码表示的-1相同的位模式。


	1+Umax(w)=2^w

当补码和无符号数转换时其权重不同，导致在当位模式中x（w-1）的值为1的时候转换值就会相差2^(w-1)的数。从有符号数转换到无符号数时将权重*2与进行本身的数值叠加，就会得到无符号数的值。

例子：[1011]在有符号时时-5，无符号数时+11 其中-5+8+8=11 


	在0到2^(w-1)无论补码到无符号数还是无符号数到补码都是值相通，剩下的部分就像积木一样直接移动到上面去，
	[1001]补码是-7无符号数就是9
	[1010]补码是-6无符号数就是10
	[1011]补码是-5无符号数就是11
	[1100]补码是-4无符号数就是12

## 2.2.5c语言的有符号数与无符号数##

大部分的数字都默认是有符号的。

在c语言中运算过程中如果一个是有符号数一个是无符号数，那么这个时候有符号数会被**隐式**转换为无符号数。

`int tx,ty;`

`unsingned ux,uy;`

`tx = ux;`

`ux = ty;`
这里就已经将数值进行了转换

## 2.2.6扩展一个数字的位表示##







